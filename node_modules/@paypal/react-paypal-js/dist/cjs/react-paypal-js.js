/*!
 * react-paypal-js v7.4.1 (2021-10-09T12:33:33.981Z)
 * Copyright 2020-present, PayPal, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * Enum for the SDK script resolve status,
 *
 * @enum {string}
 */
exports.SCRIPT_LOADING_STATE = void 0;
(function (SCRIPT_LOADING_STATE) {
    SCRIPT_LOADING_STATE["INITIAL"] = "initial";
    SCRIPT_LOADING_STATE["PENDING"] = "pending";
    SCRIPT_LOADING_STATE["REJECTED"] = "rejected";
    SCRIPT_LOADING_STATE["RESOLVED"] = "resolved";
})(exports.SCRIPT_LOADING_STATE || (exports.SCRIPT_LOADING_STATE = {}));
/**
 * Enum for the PayPalScriptProvider context dispatch actions
 *
 * @enum {string}
 */
exports.DISPATCH_ACTION = void 0;
(function (DISPATCH_ACTION) {
    DISPATCH_ACTION["LOADING_STATUS"] = "setLoadingStatus";
    DISPATCH_ACTION["RESET_OPTIONS"] = "resetOptions";
    DISPATCH_ACTION["SET_BRAINTREE_INSTANCE"] = "braintreeInstance";
})(exports.DISPATCH_ACTION || (exports.DISPATCH_ACTION = {}));
/**
 * Enum for all the available hosted fields
 *
 * @enum {string}
 */
exports.PAYPAL_HOSTED_FIELDS_TYPES = void 0;
(function (PAYPAL_HOSTED_FIELDS_TYPES) {
    PAYPAL_HOSTED_FIELDS_TYPES["NUMBER"] = "number";
    PAYPAL_HOSTED_FIELDS_TYPES["CVV"] = "cvv";
    PAYPAL_HOSTED_FIELDS_TYPES["EXPIRATION_DATE"] = "expirationDate";
    PAYPAL_HOSTED_FIELDS_TYPES["EXPIRATION_MONTH"] = "expirationMonth";
    PAYPAL_HOSTED_FIELDS_TYPES["EXPIRATION_YEAR"] = "expirationYear";
    PAYPAL_HOSTED_FIELDS_TYPES["POSTAL_CODE"] = "postalCode";
})(exports.PAYPAL_HOSTED_FIELDS_TYPES || (exports.PAYPAL_HOSTED_FIELDS_TYPES = {}));

/*********************************************
 * Common reference to the script identifier *
 *********************************************/
var SCRIPT_ID = "data-react-paypal-script-id";
var DATA_CLIENT_TOKEN = "data-client-token";
var DATA_SDK_INTEGRATION_SOURCE = "data-sdk-integration-source";
var DATA_SDK_INTEGRATION_SOURCE_VALUE = "react-paypal-js";
var DATA_NAMESPACE = "data-namespace";
/****************************
 * Braintree error messages *
 ****************************/
var EMPTY_PROVIDER_CONTEXT_CLIENT_TOKEN_ERROR_MESSAGE = "A client token wasn't found in the provider parent component";
var braintreeVersion = "3.81.0";
var BRAINTREE_SOURCE = "https://js.braintreegateway.com/web/" + braintreeVersion + "/js/client.min.js";
var BRAINTREE_PAYPAL_CHECKOUT_SOURCE = "https://js.braintreegateway.com/web/" + braintreeVersion + "/js/paypal-checkout.min.js";
/*********************
 * PayPal namespaces *
 *********************/
var DEFAULT_PAYPAL_NAMESPACE = "paypal";
var DEFAULT_BRAINTREE_NAMESPACE = "braintree";
/*****************
 * Hosted Fields *
 *****************/
var HOSTED_FIELDS_CHILDREN_ERROR = "To use HostedFields you must use it with at least 3 children with types: [number, cvv, expirationDate] includes";
var HOSTED_FIELDS_DUPLICATE_CHILDREN_ERROR = "Cannot use duplicate HostedFields as children";
/*******************
 * Script Provider *
 *******************/
var SCRIPT_PROVIDER_REDUCER_ERROR = "usePayPalScriptReducer must be used within a PayPalScriptProvider";

var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * Get the namespace from the window in the browser
 * this is useful to get the paypal object from window
 * after load PayPal SDK script
 *
 * @param namespace the name space to return
 * @returns the namespace if exists or undefined otherwise
 */
function getPayPalWindowNamespace$1(namespace) {
    if (namespace === void 0) { namespace = DEFAULT_PAYPAL_NAMESPACE; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return window[namespace];
}
/**
 * Get a namespace from the window in the browser
 * this is useful to get the braintree from window
 * after load Braintree script
 *
 * @param namespace the name space to return
 * @returns the namespace if exists or undefined otherwise
 */
function getBraintreeWindowNamespace(namespace) {
    if (namespace === void 0) { namespace = DEFAULT_BRAINTREE_NAMESPACE; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return window[namespace];
}
/**
 * Creates a string hash code based on the string argument
 *
 * @param str the source input string to hash
 * @returns string hash code
 */
function hashStr(str) {
    var hash = "";
    for (var i = 0; i < str.length; i++) {
        var total = str[i].charCodeAt(0) * i;
        if (str[i + 1]) {
            total += str[i + 1].charCodeAt(0) * (i - 1);
        }
        hash += String.fromCharCode(97 + (Math.abs(total) % 26));
    }
    return hash;
}

/**
 * Generate a new random identifier for react-paypal-js
 *
 * @returns the {@code string} containing the random library name
 */
function getScriptID(options) {
    return "react-paypal-js-" + hashStr(JSON.stringify(options));
}
/**
 * Destroy the PayPal SDK from the document page
 *
 * @param reactPayPalScriptID the script identifier
 */
function destroySDKScript(reactPayPalScriptID) {
    var scriptNode = self.document.querySelector("script[" + SCRIPT_ID + "=\"" + reactPayPalScriptID + "\"]");
    if (scriptNode === null || scriptNode === void 0 ? void 0 : scriptNode.parentNode)
        scriptNode.parentNode.removeChild(scriptNode);
}
/**
 * Reducer function to handle complex state changes on the context
 *
 * @param state  the current state on the context object
 * @param action the action to be executed on the previous state
 * @returns a the same state if the action wasn't found, or a new state otherwise
 */
function scriptReducer(state, action) {
    var _a;
    switch (action.type) {
        case exports.DISPATCH_ACTION.LOADING_STATUS:
            return __assign(__assign({}, state), { loadingStatus: action.value });
        case exports.DISPATCH_ACTION.RESET_OPTIONS:
            // destroy existing script to make sure only one script loads at a time
            destroySDKScript(state.options[SCRIPT_ID]);
            // exclude the old data-react-paypal-script-id value from the hash generated by getScriptID()
            delete action.value[SCRIPT_ID];
            return __assign(__assign({}, state), { loadingStatus: exports.SCRIPT_LOADING_STATE.PENDING, options: __assign(__assign({}, action.value), (_a = {}, _a[SCRIPT_ID] = "" + getScriptID(action.value), _a[DATA_SDK_INTEGRATION_SOURCE] = DATA_SDK_INTEGRATION_SOURCE_VALUE, _a)) });
        case exports.DISPATCH_ACTION.SET_BRAINTREE_INSTANCE:
            return __assign(__assign({}, state), { braintreePayPalCheckoutInstance: action.value });
        default: {
            return state;
        }
    }
}
// Create the React context to use in the script provider component
var ScriptContext = React.createContext(null);

/**
 * Check if the context is valid and ready to dispatch actions.
 *
 * @param scriptContext the result of connecting to the context provider
 * @returns strict context avoiding null values in the type
 */
function contextNotEmptyValidator(scriptContext) {
    if (typeof (scriptContext === null || scriptContext === void 0 ? void 0 : scriptContext.dispatch) === "function" &&
        scriptContext.dispatch.length !== 0) {
        return scriptContext;
    }
    throw new Error(SCRIPT_PROVIDER_REDUCER_ERROR);
}
/**
 * Check if the data-client-token is set in the options of the context
 * This is required to create a Braintree client
 *
 * @param scriptContext the result of connecting to the context provider
 * @returns strict context avoiding null values in the type and client token
 */
var contextOptionClientTokenNotEmptyValidator = function (scriptContext) {
    var _a;
    if (!((_a = scriptContext === null || scriptContext === void 0 ? void 0 : scriptContext.options) === null || _a === void 0 ? void 0 : _a[DATA_CLIENT_TOKEN])) {
        throw new Error(EMPTY_PROVIDER_CONTEXT_CLIENT_TOKEN_ERROR_MESSAGE);
    }
    return scriptContext;
};

/**
 * Custom hook to get access to the Script context and
 * dispatch actions to modify the state on the {@link ScriptProvider} component
 *
 * @returns a tuple containing the state of the context and
 * a dispatch function to modify the state
 */
function usePayPalScriptReducer() {
    var scriptContext = contextNotEmptyValidator(React.useContext(ScriptContext));
    var derivedStatusContext = __assign(__assign({}, scriptContext), { isInitial: scriptContext.loadingStatus === exports.SCRIPT_LOADING_STATE.INITIAL, isPending: scriptContext.loadingStatus === exports.SCRIPT_LOADING_STATE.PENDING, isResolved: scriptContext.loadingStatus === exports.SCRIPT_LOADING_STATE.RESOLVED, isRejected: scriptContext.loadingStatus === exports.SCRIPT_LOADING_STATE.REJECTED });
    return [
        derivedStatusContext,
        scriptContext.dispatch,
    ];
}
/**
 * Custom hook to get access to the ScriptProvider context
 *
 * @returns the latest state of the context
 */
function useScriptProviderContext() {
    var scriptContext = contextOptionClientTokenNotEmptyValidator(contextNotEmptyValidator(React.useContext(ScriptContext)));
    return [
        scriptContext,
        scriptContext.dispatch,
    ];
}

// Create the React context to use in the PayPal hosted fields provider
var PayPalHostedFieldsContext = React.createContext(null);

/**
 * Custom hook to get access to the PayPal Hosted Fields instance.
 * The instance represent the returned object after the render process
 * With this object a user can submit the fields and dynamically modify the cards
 *
 * @returns the hosted fields instance if is available in the component
 */
function usePayPalHostedFields() {
    return React.useContext(PayPalHostedFieldsContext);
}

/**
This `<PayPalButtons />` component renders the [Smart Payment Buttons](https://developer.paypal.com/docs/business/javascript-sdk/javascript-sdk-reference/#buttons).
It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.

Use props for customizing your buttons. For example, here's how you would use the `style`, `createOrder`, and `onApprove` options:

```jsx
    import { PayPalScriptProvider, PayPalButtons } from "@paypal/react-paypal-js";

    <PayPalScriptProvider options={{ "client-id": "test" }}>
        <PayPalButtons
            style={{ layout: "horizontal" }}
            createOrder={(data, actions) => {
                return actions.order.create({
                    purchase_units: [
                        {
                            amount: {
                                value: "2.00",
                            },
                        },
                    ],
                });
            }}
        />;
    </PayPalScriptProvider>
```
*/
var PayPalButtons = function (_a) {
    var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, children = _a.children, _d = _a.forceReRender, forceReRender = _d === void 0 ? [] : _d, buttonProps = __rest(_a, ["className", "disabled", "children", "forceReRender"]);
    var isDisabledStyle = disabled ? { opacity: 0.38 } : {};
    var classNames = (className + " " + (disabled ? "paypal-buttons-disabled" : "")).trim();
    var buttonsContainerRef = React.useRef(null);
    var buttons = React.useRef(null);
    var _e = usePayPalScriptReducer()[0], isResolved = _e.isResolved, options = _e.options;
    var _f = React.useState(null), initActions = _f[0], setInitActions = _f[1];
    var _g = React.useState(true), isEligible = _g[0], setIsEligible = _g[1];
    var _h = React.useState(null), setErrorState = _h[1];
    function closeButtonsComponent() {
        if (buttons.current !== null) {
            buttons.current.close().catch(function () {
                // ignore errors when closing the component
            });
        }
    }
    // useEffect hook for rendering the buttons
    React.useEffect(function () {
        // verify the sdk script has successfully loaded
        if (isResolved === false) {
            return closeButtonsComponent;
        }
        var paypalWindowNamespace = getPayPalWindowNamespace$1(options[DATA_NAMESPACE]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Buttons === undefined) {
            setErrorState(function () {
                throw new Error(getErrorMessage$2(options));
            });
            return closeButtonsComponent;
        }
        var decoratedOnInit = function (data, actions) {
            setInitActions(actions);
            if (typeof buttonProps.onInit === "function") {
                buttonProps.onInit(data, actions);
            }
        };
        try {
            buttons.current = paypalWindowNamespace.Buttons(__assign(__assign({}, buttonProps), { onInit: decoratedOnInit }));
        }
        catch (err) {
            return setErrorState(function () {
                throw new Error("Failed to render <PayPalButtons /> component. Failed to initialize:  " + err);
            });
        }
        // only render the button when eligible
        if (buttons.current.isEligible() === false) {
            setIsEligible(false);
            return closeButtonsComponent;
        }
        if (!buttonsContainerRef.current) {
            return closeButtonsComponent;
        }
        buttons.current.render(buttonsContainerRef.current).catch(function (err) {
            // component failed to render, possibly because it was closed or destroyed.
            if (buttonsContainerRef.current === null ||
                buttonsContainerRef.current.children.length === 0) {
                // paypal buttons container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal buttons container is still in the DOM
            setErrorState(function () {
                throw new Error("Failed to render <PayPalButtons /> component. " + err);
            });
        });
        return closeButtonsComponent;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, __spreadArray(__spreadArray([isResolved], forceReRender, true), [buttonProps.fundingSource], false));
    // useEffect hook for managing disabled state
    React.useEffect(function () {
        if (initActions === null) {
            return;
        }
        if (disabled === true) {
            initActions.disable().catch(function () {
                // ignore errors when disabling the component
            });
        }
        else {
            initActions.enable().catch(function () {
                // ignore errors when enabling the component
            });
        }
    }, [disabled, initActions]);
    return (React__default["default"].createElement(React__default["default"].Fragment, null, isEligible ? (React__default["default"].createElement("div", { ref: buttonsContainerRef, style: isDisabledStyle, className: classNames })) : (children)));
};
function getErrorMessage$2(_a) {
    var _b = _a.components, components = _b === void 0 ? "" : _b, _c = DATA_NAMESPACE, _d = _a[_c], dataNamespace = _d === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _d;
    var errorMessage = "Unable to render <PayPalButtons /> because window." + dataNamespace + ".Buttons is undefined.";
    // the JS SDK includes the Buttons component by default when no 'components' are specified.
    // The 'buttons' component must be included in the 'components' list when using it with other components.
    if (components.length && !components.includes("buttons")) {
        var expectedComponents = components + ",buttons";
        errorMessage +=
            "\nTo fix the issue, add 'buttons' to the list of components passed to the parent PayPalScriptProvider:" +
                ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
    }
    return errorMessage;
}

function findScript(url, attributes) {
  var currentScript = document.querySelector("script[src=\"" + url + "\"]");
  if (currentScript === null) return null;
  var nextScript = createScriptElement(url, attributes);
  var currentScriptDataset = Object.assign({}, currentScript.dataset);
  delete currentScriptDataset.uidAuto;
  if (Object.keys(currentScriptDataset).length !== Object.keys(nextScript.dataset).length) {
    return null;
  }
  var isExactMatch = true;
  Object.keys(currentScriptDataset).forEach(function (key) {
    if (currentScriptDataset[key] !== nextScript.dataset[key]) {
      isExactMatch = false;
    }
  });
  return isExactMatch ? currentScript : null;
}
function insertScriptElement(_a) {
  var url = _a.url,
      attributes = _a.attributes,
      onSuccess = _a.onSuccess,
      onError = _a.onError;
  var newScript = createScriptElement(url, attributes);
  newScript.onerror = onError;
  newScript.onload = onSuccess;
  document.head.insertBefore(newScript, document.head.firstElementChild);
}
function processOptions(options) {
  var sdkBaseURL = "https://www.paypal.com/sdk/js";
  if (options.sdkBaseURL) {
    sdkBaseURL = options.sdkBaseURL;
    delete options.sdkBaseURL;
  }
  var processedMerchantIDAttributes = processMerchantID(options["merchant-id"], options["data-merchant-id"]);
  var newOptions = Object.assign({}, options, processedMerchantIDAttributes);
  var _a = Object.keys(newOptions).filter(function (key) {
    return typeof newOptions[key] !== "undefined" && newOptions[key] !== null && newOptions[key] !== "";
  }).reduce(function (accumulator, key) {
    var value = newOptions[key].toString();
    if (key.substring(0, 5) === "data-") {
      accumulator.dataAttributes[key] = value;
    } else {
      accumulator.queryParams[key] = value;
    }
    return accumulator;
  }, {
    queryParams: {},
    dataAttributes: {}
  }),
      queryParams = _a.queryParams,
      dataAttributes = _a.dataAttributes;
  return {
    url: sdkBaseURL + "?" + objectToQueryString(queryParams),
    dataAttributes: dataAttributes
  };
}
function objectToQueryString(params) {
  var queryString = "";
  Object.keys(params).forEach(function (key) {
    if (queryString.length !== 0) queryString += "&";
    queryString += key + "=" + params[key];
  });
  return queryString;
}
function createScriptElement(url, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }
  var newScript = document.createElement("script");
  newScript.src = url;
  Object.keys(attributes).forEach(function (key) {
    newScript.setAttribute(key, attributes[key]);
    if (key === "data-csp-nonce") {
      newScript.setAttribute("nonce", attributes["data-csp-nonce"]);
    }
  });
  return newScript;
}
function processMerchantID(merchantID, dataMerchantID) {
  var newMerchantID = "";
  var newDataMerchantID = "";
  if (Array.isArray(merchantID)) {
    if (merchantID.length > 1) {
      newMerchantID = "*";
      newDataMerchantID = merchantID.toString();
    } else {
      newMerchantID = merchantID.toString();
    }
  } else if (typeof merchantID === "string" && merchantID.length > 0) {
    newMerchantID = merchantID;
  } else if (typeof dataMerchantID === "string" && dataMerchantID.length > 0) {
    newMerchantID = "*";
    newDataMerchantID = dataMerchantID;
  }
  return {
    "merchant-id": newMerchantID,
    "data-merchant-id": newDataMerchantID
  };
}
function loadScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }
  validateArguments(options, PromisePonyfill);
  if (typeof window === "undefined") return PromisePonyfill.resolve(null);
  var _a = processOptions(options),
      url = _a.url,
      dataAttributes = _a.dataAttributes;
  var namespace = dataAttributes["data-namespace"] || "paypal";
  var existingWindowNamespace = getPayPalWindowNamespace(namespace);
  if (findScript(url, dataAttributes) && existingWindowNamespace) {
    return PromisePonyfill.resolve(existingWindowNamespace);
  }
  return loadCustomScript({
    url: url,
    attributes: dataAttributes
  }, PromisePonyfill).then(function () {
    var newWindowNamespace = getPayPalWindowNamespace(namespace);
    if (newWindowNamespace) {
      return newWindowNamespace;
    }
    throw new Error("The window." + namespace + " global variable is not available.");
  });
}
function loadCustomScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }
  validateArguments(options, PromisePonyfill);
  var url = options.url,
      attributes = options.attributes;
  if (typeof url !== "string" || url.length === 0) {
    throw new Error("Invalid url.");
  }
  if (typeof attributes !== "undefined" && typeof attributes !== "object") {
    throw new Error("Expected attributes to be an object.");
  }
  return new PromisePonyfill(function (resolve, reject) {
    if (typeof window === "undefined") return resolve();
    insertScriptElement({
      url: url,
      attributes: attributes,
      onSuccess: function onSuccess() {
        return resolve();
      },
      onError: function onError() {
        return reject(new Error("The script \"" + url + "\" failed to load."));
      }
    });
  });
}
function getDefaultPromiseImplementation() {
  if (typeof Promise === "undefined") {
    throw new Error("Promise is undefined. To resolve the issue, use a Promise polyfill.");
  }
  return Promise;
}
function getPayPalWindowNamespace(namespace) {
  return window[namespace];
}
function validateArguments(options, PromisePonyfill) {
  if (typeof options !== "object" || options === null) {
    throw new Error("Expected an options object.");
  }
  if (typeof PromisePonyfill !== "undefined" && typeof PromisePonyfill !== "function") {
    throw new Error("Expected PromisePonyfill to be a function.");
  }
}

/**
 * Override the createOrder callback to send the PayPal checkout instance as argument
 * to the defined createOrder function for braintree component button
 *
 * @param braintreeButtonProps the component button options
 */
var decorateCreateOrder = function (braintreeButtonProps, payPalCheckoutInstance) {
    if (typeof braintreeButtonProps.createOrder === "function") {
        // Keep the createOrder function reference
        var functionReference_1 = braintreeButtonProps.createOrder;
        braintreeButtonProps.createOrder = function (data, actions) {
            return functionReference_1(data, __assign(__assign({}, actions), { braintree: payPalCheckoutInstance }));
        };
    }
};
/**
 * Override the onApprove callback to send the payload as argument
 * to the defined onApprove function for braintree component button
 *
 * @param braintreeButtonProps the component button options
 */
var decorateOnApprove = function (braintreeButtonProps, payPalCheckoutInstance) {
    if (typeof braintreeButtonProps.onApprove === "function") {
        // Store the createOrder function reference
        var braintreeOnApprove_1 = braintreeButtonProps.onApprove;
        braintreeButtonProps.onApprove = function (data, actions) {
            return braintreeOnApprove_1(data, __assign(__assign({}, actions), { braintree: payPalCheckoutInstance }));
        };
    }
};
/**
 * Use `actions.braintree` to provide an interface for the paypalCheckoutInstance
 * through the createOrder and onApprove callbacks
 *
 * @param braintreeButtonProps the component button options
 * @returns a new copy of the component button options casted as {@link PayPalButtonsComponentProps}
 */
var decorateActions = function (buttonProps, payPalCheckoutInstance) {
    decorateCreateOrder(buttonProps, payPalCheckoutInstance);
    decorateOnApprove(buttonProps, payPalCheckoutInstance);
    return __assign({}, buttonProps);
};

/**
This `<BraintreePayPalButtons />` component renders the [Braintree PayPal Buttons](https://developer.paypal.com/braintree/docs/guides/paypal/overview) for Braintree Merchants.
It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.

Use props for customizing your buttons. For example, here's how you would use the `style`, `createOrder`, and `onApprove` options:

```jsx
    import { PayPalScriptProvider, BraintreePayPalButtons } from "@paypal/react-paypal-js";

    <PayPalScriptProvider options={{ "client-id": "test" }}>
        <BraintreePayPalButtons
            style={{ layout: "horizontal" }}
            createOrder={(data, actions) => {
                // the paypalCheckoutInstance from the braintree sdk integration is added to `actions.braintree`
                return actions.braintree.createPayment({
                    flow: "checkout",
                    amount: "10.0",
                    currency: "USD",
                    intent: "capture"
                })
            }}
            onApprove={(data, actions) => {
                return actions.braintree.tokenizePayment(data)
                    .then((payload) => {
                        // call server-side endpoint to finish the sale
                    })
            }
        />
    </PayPalScriptProvider>
```

*/
var BraintreePayPalButtons = function (_a) {
    var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.disabled, disabled = _c === void 0 ? false : _c, children = _a.children, _d = _a.forceReRender, forceReRender = _d === void 0 ? [] : _d, buttonProps = __rest(_a, ["className", "disabled", "children", "forceReRender"]);
    var _e = React.useState(null), setErrorState = _e[1];
    var _f = useScriptProviderContext(), providerContext = _f[0], dispatch = _f[1];
    React.useEffect(function () {
        Promise.all([
            loadCustomScript({ url: BRAINTREE_SOURCE }),
            loadCustomScript({ url: BRAINTREE_PAYPAL_CHECKOUT_SOURCE }),
        ])
            .then(function () {
            var clientToken = providerContext.options[DATA_CLIENT_TOKEN];
            var braintreeNamespace = getBraintreeWindowNamespace();
            return braintreeNamespace.client
                .create({
                authorization: clientToken,
            })
                .then(function (clientInstance) {
                return braintreeNamespace.paypalCheckout.create({
                    client: clientInstance,
                });
            })
                .then(function (paypalCheckoutInstance) {
                dispatch({
                    type: exports.DISPATCH_ACTION.SET_BRAINTREE_INSTANCE,
                    value: paypalCheckoutInstance,
                });
            });
        })
            .catch(function (err) {
            setErrorState(function () {
                throw new Error("An error occurred when loading the Braintree scripts: " + err);
            });
        });
    }, [providerContext.options, dispatch]);
    return (React__default["default"].createElement(React__default["default"].Fragment, null, providerContext.braintreePayPalCheckoutInstance && (React__default["default"].createElement(PayPalButtons, __assign({ className: className, disabled: disabled, forceReRender: forceReRender }, decorateActions(buttonProps, providerContext.braintreePayPalCheckoutInstance)), children))));
};

/**
The `<PayPalMarks />` component is used for conditionally rendering different payment options using radio buttons.
The [Display PayPal Buttons with other Payment Methods guide](https://developer.paypal.com/docs/business/checkout/add-capabilities/buyer-experience/#display-paypal-buttons-with-other-payment-methods) describes this style of integration in detail.
It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.
```jsx
    <PayPalMarks />
```
This component can also be configured to use a single funding source similar to the [standalone buttons](https://developer.paypal.com/docs/business/checkout/configure-payments/standalone-buttons/) approach.
A `FUNDING` object is exported by this library which has a key for every available funding source option.
```jsx
    import { PayPalScriptProvider, PayPalMarks, FUNDING } from "@paypal/react-paypal-js";
    <PayPalScriptProvider options={{ "client-id": "test", components: "buttons,marks" }}>
        <PayPalMarks fundingSource={FUNDING.PAYPAL}/>
    </PayPalScriptProvider>
```
*/
var PayPalMarks = function (_a) {
    var _b = _a.className, className = _b === void 0 ? "" : _b, children = _a.children, markProps = __rest(_a, ["className", "children"]);
    var _c = usePayPalScriptReducer()[0], isResolved = _c.isResolved, options = _c.options;
    var markContainerRef = React.useRef(null);
    var _d = React.useState(true), isEligible = _d[0], setIsEligible = _d[1];
    var _e = React.useState(null), setErrorState = _e[1];
    /**
     * Render PayPal Mark into the DOM
     */
    var renderPayPalMark = function (mark) {
        var current = markContainerRef.current;
        // only render the mark when eligible
        if (!current || !mark.isEligible()) {
            return setIsEligible(false);
        }
        // Remove any children before render it again
        if (current.firstChild) {
            current.removeChild(current.firstChild);
        }
        mark.render(current).catch(function (err) {
            // component failed to render, possibly because it was closed or destroyed.
            if (current === null || current.children.length === 0) {
                // paypal marks container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal marks container is still in the DOM
            setErrorState(function () {
                throw new Error("Failed to render <PayPalMarks /> component. " + err);
            });
        });
    };
    React.useEffect(function () {
        // verify the sdk script has successfully loaded
        if (isResolved === false)
            return;
        var paypalWindowNamespace = getPayPalWindowNamespace$1(options[DATA_NAMESPACE]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Marks === undefined) {
            setErrorState(function () {
                throw new Error(getErrorMessage$1(options));
            });
            return;
        }
        renderPayPalMark(paypalWindowNamespace.Marks(__assign({}, markProps)));
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isResolved, markProps.fundingSource]);
    return (React__default["default"].createElement(React__default["default"].Fragment, null, isEligible ? (React__default["default"].createElement("div", { ref: markContainerRef, className: className })) : (children)));
};
function getErrorMessage$1(_a) {
    var _b = _a.components, components = _b === void 0 ? "" : _b, _c = DATA_NAMESPACE, _d = _a[_c], dataNamespace = _d === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _d;
    var errorMessage = "Unable to render <PayPalMarks /> because window." + dataNamespace + ".Marks is undefined.";
    // the JS SDK does not load the Marks component by default. It must be passed into the "components" query parameter.
    if (!components.includes("marks")) {
        var expectedComponents = components ? components + ",marks" : "marks";
        errorMessage +=
            "\nTo fix the issue, add 'marks' to the list of components passed to the parent PayPalScriptProvider:" +
                ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
    }
    return errorMessage;
}

var PayPalMessages = function (_a) {
    var _b = _a.className, className = _b === void 0 ? "" : _b, _c = _a.forceReRender, forceReRender = _c === void 0 ? [] : _c, messageProps = __rest(_a, ["className", "forceReRender"]);
    var _d = usePayPalScriptReducer()[0], isResolved = _d.isResolved, options = _d.options;
    var messagesContainerRef = React.useRef(null);
    var messages = React.useRef(null);
    var _e = React.useState(null), setErrorState = _e[1];
    React.useEffect(function () {
        // verify the sdk script has successfully loaded
        if (isResolved === false) {
            return;
        }
        var paypalWindowNamespace = getPayPalWindowNamespace$1(options[DATA_NAMESPACE]);
        // verify dependency on window object
        if (paypalWindowNamespace === undefined ||
            paypalWindowNamespace.Messages === undefined) {
            setErrorState(function () {
                throw new Error(getErrorMessage(options));
            });
            return;
        }
        messages.current = paypalWindowNamespace.Messages(__assign({}, messageProps));
        if (messagesContainerRef.current === null) {
            return;
        }
        messages.current
            .render(messagesContainerRef.current)
            .catch(function (err) {
            // component failed to render, possibly because it was closed or destroyed.
            if (messagesContainerRef.current === null ||
                messagesContainerRef.current.children.length === 0) {
                // paypal messages container is no longer in the DOM, we can safely ignore the error
                return;
            }
            // paypal messages container is still in the DOM
            setErrorState(function () {
                throw new Error("Failed to render <PayPalMessages /> component. " + err);
            });
        });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, __spreadArray([isResolved], forceReRender, true));
    return React__default["default"].createElement("div", { ref: messagesContainerRef, className: className });
};
function getErrorMessage(_a) {
    var _b = _a.components, components = _b === void 0 ? "" : _b, _c = DATA_NAMESPACE, _d = _a[_c], dataNamespace = _d === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _d;
    var errorMessage = "Unable to render <PayPalMessages /> because window." + dataNamespace + ".Messages is undefined.";
    // the JS SDK does not load the Messages component by default. It must be passed into the "components" query parameter.
    if (!components.includes("messages")) {
        var expectedComponents = components
            ? components + ",messages"
            : "messages";
        errorMessage +=
            "\nTo fix the issue, add 'messages' to the list of components passed to the parent PayPalScriptProvider:" +
                ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
    }
    return errorMessage;
}

var PayPalScriptProvider = function (_a) {
    var _b;
    var _c = _a.options, options = _c === void 0 ? { "client-id": "test" } : _c, children = _a.children, _d = _a.deferLoading, deferLoading = _d === void 0 ? false : _d;
    var _e = React.useReducer(scriptReducer, {
        options: __assign(__assign({}, options), (_b = {}, _b[SCRIPT_ID] = "" + getScriptID(options), _b[DATA_SDK_INTEGRATION_SOURCE] = DATA_SDK_INTEGRATION_SOURCE_VALUE, _b)),
        loadingStatus: deferLoading
            ? exports.SCRIPT_LOADING_STATE.INITIAL
            : exports.SCRIPT_LOADING_STATE.PENDING,
    }), state = _e[0], dispatch = _e[1];
    React.useEffect(function () {
        if (deferLoading === false &&
            state.loadingStatus === exports.SCRIPT_LOADING_STATE.INITIAL) {
            return dispatch({
                type: exports.DISPATCH_ACTION.LOADING_STATUS,
                value: exports.SCRIPT_LOADING_STATE.PENDING,
            });
        }
        if (state.loadingStatus !== exports.SCRIPT_LOADING_STATE.PENDING)
            return;
        var isSubscribed = true;
        loadScript(state.options)
            .then(function () {
            if (isSubscribed) {
                dispatch({
                    type: exports.DISPATCH_ACTION.LOADING_STATUS,
                    value: exports.SCRIPT_LOADING_STATE.RESOLVED,
                });
            }
        })
            .catch(function () {
            if (isSubscribed) {
                dispatch({
                    type: exports.DISPATCH_ACTION.LOADING_STATUS,
                    value: exports.SCRIPT_LOADING_STATE.REJECTED,
                });
            }
        });
        return function () {
            isSubscribed = false;
        };
    }, [state.options, deferLoading, state.loadingStatus]);
    return (React__default["default"].createElement(ScriptContext.Provider, { value: __assign(__assign({}, state), { dispatch: dispatch }) }, children));
};

/**
 * Throw an exception if the HostedFields is not found in the paypal namespace
 * Probably cause for this problem is not sending the hosted-fields string
 * as part of the components props in options
 * {@code <PayPalScriptProvider options={{ components: 'hosted-fields'}}>}
 *
 * @param param0 and object containing the components and namespace defined in options
 * @throws {@code Error}
 *
 */
var throwMissingHostedFieldsError = function (_a) {
    var _b = _a.components, components = _b === void 0 ? "" : _b, _c = DATA_NAMESPACE, _d = _a[_c], dataNamespace = _d === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _d;
    var expectedComponents = components
        ? components + ",hosted-fields"
        : "hosted-fields";
    var errorMessage = "Unable to render <PayPalHostedFieldsProvider /> because window." + dataNamespace + ".HostedFields is undefined.";
    if (!components.includes("hosted-fields")) {
        errorMessage += "\nTo fix the issue, add 'hosted-fields' to the list of components passed to the parent PayPalScriptProvider: <PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>";
    }
    throw new Error(errorMessage);
};
/**
 * Identify all the valid hosted fields children and generate the valid options
 * to use in the HostedFields.render process
 *
 * @param childrenList     the list of children received
 * @param possibleChildren a list of child type to transform into fields format
 * @returns the fields object required to render the HostedFields
 */
var generateHostedFieldsFromChildren = function (childrenList) {
    return childrenList.reduce(function (fields, child) {
        var _a = child.props, hostedFieldType = _a.hostedFieldType, options = _a.options;
        if (Object.values(exports.PAYPAL_HOSTED_FIELDS_TYPES).includes(hostedFieldType)) {
            fields[hostedFieldType] = {
                selector: options.selector,
                placeholder: options.placeholder,
                type: options.type,
                formatInput: options.formatInput,
                maskInput: options.maskInput,
                select: options.select,
                maxlength: options.maxlength,
                minlength: options.minlength,
                prefill: options.prefill,
                rejectUnsupportedCards: options.rejectUnsupportedCards,
            };
        }
        return fields;
    }, {});
};

/**
 * Get only PayPalHostedField children, exclude all the other children
 *
 * @param childrenList the list of children
 * @returns a new list containing only the PayPalHostedField components
 */
var getPayPalHostedFieldChildren = function (childrenList) {
    return childrenList.reduce(function (accumulator, child) {
        var reactElement = child;
        if (reactElement.props.hostedFieldType) {
            accumulator.push(reactElement.props.hostedFieldType);
        }
        return accumulator;
    }, []);
};
/**
 * Validate the expiration date children. Valid combinations are:
 * 1- Exists expirationDate field and not exists expirationMonth and expirationYear fields
 * 2- Exists expirationMonth and expirationYear and not exists expirationDate
 * All the other possible combinations are invalid
 *
 * @param registerTypes
 * @returns @type {true} when the children are valid
 */
var validateExpirationDate = function (registerTypes) {
    return (!registerTypes.includes(exports.PAYPAL_HOSTED_FIELDS_TYPES.EXPIRATION_DATE) &&
        !registerTypes.includes(exports.PAYPAL_HOSTED_FIELDS_TYPES.EXPIRATION_MONTH) &&
        !registerTypes.includes(exports.PAYPAL_HOSTED_FIELDS_TYPES.EXPIRATION_YEAR));
};
/**
 * Check if we find the [number, expiration, cvv] in children
 *
 * @param requiredChildren the list with required children [number, expiration, cvv]
 * @param registerTypes    the list of all the children types pass to the parent
 * @throw an @type {Error} when not find the default children
 */
var hasDefaultChildren = function (registerTypes) {
    if (!registerTypes.includes(exports.PAYPAL_HOSTED_FIELDS_TYPES.NUMBER) ||
        !registerTypes.includes(exports.PAYPAL_HOSTED_FIELDS_TYPES.CVV) ||
        validateExpirationDate(registerTypes)) {
        throw new Error(HOSTED_FIELDS_CHILDREN_ERROR);
    }
};
/**
 * Check if we don't have duplicate children types
 *
 * @param registerTypes the list of all the children types pass to the parent
 * @throw an @type {Error} when duplicate types was found
 */
var notDuplicateChildren = function (registerTypes) {
    if (registerTypes.length !== new Set(registerTypes).size) {
        throw new Error(HOSTED_FIELDS_DUPLICATE_CHILDREN_ERROR);
    }
};
/**
 * Validate the hosted fields children past to the PayPalHostedFieldsProvider component
 * These are the rule:
 * 1- We need to find 3 default children type [[number, expiration, cvv]
 * 2- We cannot find duplicate children type
 * 3- We cannot find expirationDate field combine with expirationMonth and expirationYear
 *
 * @param childrenList     the list of children
 * @param requiredChildren the list with required children [number, expiration, cvv]
 */
var validateHostedFieldChildren = function (childrenList) {
    var registerTypes = getPayPalHostedFieldChildren(childrenList);
    hasDefaultChildren(registerTypes);
    notDuplicateChildren(registerTypes);
};

/**
This `<PayPalHostedFieldsProvider />` provider component wraps the form field elements and accepts props like `createOrder()`.

This provider component is designed to be used with the `<PayPalHostedField />` component.
*/
var PayPalHostedFieldsProvider = function (_a) {
    var styles = _a.styles, createOrder = _a.createOrder, notEligibleError = _a.notEligibleError, children = _a.children;
    var childrenList = React.Children.toArray(children);
    var _b = useScriptProviderContext()[0], options = _b.options, loadingStatus = _b.loadingStatus;
    var _c = React.useState(true), isEligible = _c[0], setIsEligible = _c[1];
    var _d = React.useState(null), cardFields = _d[0], setCardFields = _d[1];
    var hostedFieldsContainerRef = React.useRef(null);
    var hostedFields = React.useRef();
    var _e = React.useState(null), setErrorState = _e[1];
    /**
     * Executed on the mount process to validate the children
     */
    React.useEffect(function () {
        validateHostedFieldChildren(childrenList);
    }, []); // eslint-disable-line react-hooks/exhaustive-deps
    React.useEffect(function () {
        var _a;
        var _b;
        // Only render the hosted fields when script is loaded and hostedFields is eligible
        if (!(loadingStatus === exports.SCRIPT_LOADING_STATE.RESOLVED))
            return;
        // Get the hosted fields from the [window.paypal.HostedFields] SDK
        if (!hostedFields.current) {
            // Set HostedFields SDK in the mount process only
            hostedFields.current = getPayPalWindowNamespace$1(options[DATA_NAMESPACE]).HostedFields;
            if (!hostedFields.current) {
                throwMissingHostedFieldsError((_a = {
                        components: options.components
                    },
                    _a[DATA_NAMESPACE] = options[DATA_NAMESPACE],
                    _a));
            }
        }
        if (!((_b = hostedFields === null || hostedFields === void 0 ? void 0 : hostedFields.current) === null || _b === void 0 ? void 0 : _b.isEligible())) {
            return setIsEligible(false);
        }
        // Clean all the fields before the rerender
        if (cardFields) {
            cardFields.teardown();
        }
        hostedFields.current
            .render({
            // Call your server to set up the transaction
            createOrder: createOrder,
            styles: styles,
            fields: generateHostedFieldsFromChildren(childrenList),
        })
            .then(function (cardFieldsInstance) {
            setCardFields(cardFieldsInstance);
        })
            .catch(function (err) {
            setErrorState(function () {
                throw new Error("Failed to render <PayPalHostedFieldsProvider /> component. " + err);
            });
        });
    }, [loadingStatus, styles]); // eslint-disable-line react-hooks/exhaustive-deps
    return (React__default["default"].createElement("div", { ref: hostedFieldsContainerRef }, isEligible ? (React__default["default"].createElement(PayPalHostedFieldsContext.Provider, { value: cardFields }, children)) : (notEligibleError)));
};

/**
This `<PayPalHostedField />` component renders individual fields for [Hosted Fields](https://developer.paypal.com/docs/business/checkout/advanced-card-payments/integrate#3-add-javascript-sdk-and-card-form) integrations.
It relies on the `<PayPalHostedFieldsProvider />` parent component for managing state related to loading the JS SDK script
and execute some validations before the rendering the fields.

Use props for customizing your hosted fields. For example, here's how you would use the `style`, `className`, `id` options:

```jsx
    import {
        PayPalScriptProvider,
        PayPalHostedFieldsProvider,
        PayPalHostedField
    } from "@paypal/react-paypal-js";

    <PayPalScriptProvider options={{ "client-id": "test" }}>
        <PayPalHostedFieldsProvider
            createOrder={() => {
                // Manually call your server endpoint to create the client order
                return fetch("create_order_endpoint")
                    .then(response => response.json())
                    .then(order => order.id)
                    .catch(err => {
                        // Handle exceptions
                    })
            }}
        >
            <PayPalHostedField style={{ color: "red", border: "1px solid" }}
                id="card-number"
                hostedFieldType="number"
                options={{ selector: "#card-number", placeholder: "4111 1111 1111 1111" }} />
            <PayPalHostedField id="cvv"
                hostedFieldType="cvv"
                options={{ selector: "#cvv", placeholder: "CVV", maxlength: 3, maskInput: true }} />
            <PayPalHostedField id="expiration-date"
                hostedFieldType="expirationDate"
                options={{ selector: "#expiration-date", placeholder: "MM/YY" }} />

        </PayPalHostedFieldsProvider>
    </PayPalScriptProvider>
```

To use the PayPal hosted fields you need to define at least three fields:
    - A card number field
    - The CVV code from the client card
    - The expiration date

You can define the expiration date as a single field similar to the example above,
or you are able to define it in two separate fields. One for the month and second for year.
You can delete the last children component form the example above and use these:

```jsx
    <PayPalHostedField id="expiration-month"
        hostedFieldType={PAYPAL_HOSTED_FIELDS_TYPES.EXPIRATION_MONTH}
        options={{ selector: "#expiration-month", placeholder: "MM" }} />
    <PayPalHostedField id="expiration-year"
        hostedFieldType={PAYPAL_HOSTED_FIELDS_TYPES.EXPIRATION_YEAR}
        options={{ selector: "#expiration-year", placeholder: "YYYY" }} />
```

Note: Take care when using multiple instances of the PayPal Hosted Fields on the same page.
The component will fail to render when any of the selectors return more than one element.
*/
var PayPalHostedField = function (_a) {
    _a.hostedFieldType; // eslint-disable-line @typescript-eslint/no-unused-vars
    _a.options; // eslint-disable-line @typescript-eslint/no-unused-vars
    var props = __rest(_a, ["hostedFieldType", "options"]);
    return React__default["default"].createElement("div", __assign({}, props));
};

var FUNDING$1 = {
  PAYPAL: 'paypal',
  VENMO: 'venmo',
  APPLEPAY: 'applepay',
  ITAU: 'itau',
  CREDIT: 'credit',
  PAYLATER: 'paylater',
  CARD: 'card',
  IDEAL: 'ideal',
  SEPA: 'sepa',
  BANCONTACT: 'bancontact',
  GIROPAY: 'giropay',
  SOFORT: 'sofort',
  EPS: 'eps',
  MYBANK: 'mybank',
  P24: 'p24',
  VERKKOPANKKI: 'verkkopankki',
  PAYU: 'payu',
  BLIK: 'blik',
  TRUSTLY: 'trustly',
  ZIMPLER: 'zimpler',
  MAXIMA: 'maxima',
  OXXO: 'oxxo',
  BOLETO: 'boleto',
  WECHATPAY: 'wechatpay',
  MERCADOPAGO: 'mercadopago'
};

// We do not re-export `FUNDING` from the `sdk-constants` module
// directly because it has no type definitions.
//
// See https://github.com/paypal/react-paypal-js/issues/125
var FUNDING = FUNDING$1;

exports.BraintreePayPalButtons = BraintreePayPalButtons;
exports.FUNDING = FUNDING;
exports.PayPalButtons = PayPalButtons;
exports.PayPalHostedField = PayPalHostedField;
exports.PayPalHostedFieldsProvider = PayPalHostedFieldsProvider;
exports.PayPalMarks = PayPalMarks;
exports.PayPalMessages = PayPalMessages;
exports.PayPalScriptProvider = PayPalScriptProvider;
exports.ScriptContext = ScriptContext;
exports.destroySDKScript = destroySDKScript;
exports.getScriptID = getScriptID;
exports.scriptReducer = scriptReducer;
exports.usePayPalHostedFields = usePayPalHostedFields;
exports.usePayPalScriptReducer = usePayPalScriptReducer;
exports.useScriptProviderContext = useScriptProviderContext;
